#!/usr/bin/env python

import argparse
import multiprocessing
import os
import subprocess
import sys
import time
from ConfigParser import SafeConfigParser

import boto


def get_instance(conn, name):
    reservations = conn.get_all_instances(filters={'tag:Name': 'quickness', 'tag:Quickness': name})
    for res in reservations:
        for instance in res.instances:
            return instance


def copy_private(name):
    conn = boto.connect_ec2()
    instance = get_instance(conn, name)

    if not instance:
        print 'Unable to find instance %s' % name
        return

    # Time to copy in the private files
    if 0 != subprocess.call('scp -i $AWS_IDENTITY -o StrictHostKeyChecking=no etc/private/* ubuntu@%s:~/.quickness_repo/etc/private' % instance.public_dns_name, shell=True):
        print '%s - unable to scp etc/private' % name
    if 0 != subprocess.call('scp -i $AWS_IDENTITY -o StrictHostKeyChecking=no formulas/*_private ubuntu@%s:~/.quickness_repo/formulas' % instance.public_dns_name, shell=True):
        print '%s - unable to scp private formulas' % name
    if 0 != subprocess.call('scp -i $AWS_IDENTITY -o StrictHostKeyChecking=no tweaks/*_private ubuntu@%s:~/.quickness_repo/tweaks' % instance.public_dns_name, shell=True):
        print '%s - unable to scp private tweaks' % name

    print '%s [%s]: %s (%s)' % (name, instance.id, instance.state, instance.public_dns_name)
    print 'To login: bin/quick_ec2 ssh %s' % name


if __name__ == '__main__':
    aparser = argparse.ArgumentParser(description='Create an ec2 instance.')
    aparser.add_argument('-f', '--file', dest='filename', default='ec2.conf',
                               help='Name of the config file in etc/private - defaults to ec2.conf')
    args = aparser.parse_args()


    cparser = SafeConfigParser()
    cparser.read(os.path.join('etc/private/', args.filename))


    try:
        aws_identity = os.environ['AWS_IDENTITY']
    except KeyError:
        print 'Please set the AWS_IDENTITY environment variable to create a new ec2 machine'
        sys.exit()

    sqs = boto.connect_sqs()
    q = sqs.get_queue(cparser.defaults()['queue'])
    print 'polling... <ctrl-c to quit>'
    finished = False
    while not finished:
        time.sleep(3)
        rs = q.get_messages()
        for m in rs:
            body = m.get_body()
            print body
            q.delete_message(m)
            name, process, status = body.split(':')
            if process == 'bootstrap' and status == 'finished':
                p = multiprocessing.Process(target=copy_private, args=(name,))
                p.start()
